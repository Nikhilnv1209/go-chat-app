# Story: Typing Indicators

**Feature ID**: F07
**Story IDs**: S07.01 (Typing Start), S07.02 (Typing Stop)
**Epic**: E01 - MVP
**Status**: TODO
**Owner**: Developer Agent
**Test Cases**: T07.01, T07.02

---

## User Story
**As a** user,
**I want to** see when someone is typing a message to me,
**So that** I know they are actively responding.

---

## Requirements Covered
- [R11] Real-time typing status broadcast
- [R12] Automatic timeout for stale typing indicators

---

## Technical Context
*   **Stateless**: No database persistence required (ephemeral state).
*   **WebSocket-only**: Uses Hub to broadcast typing events.
*   **Timeout**: Client should send `typing_stop` after 3 seconds of inactivity.

---

## Files to Create/Modify
| File | Action |
|------|--------|
| `internal/websocket/message_handler.go` | MODIFY - Handle `typing_start` and `typing_stop` events |
| `internal/websocket/hub.go` | MODIFY (Optional) - Add typing state tracking |

---

## Event Flow

### 1. User Starts Typing
1.  **Client** (User A): Detects input in message box, sends:
    ```json
    {
      "type": "typing_start",
      "payload": {
        "conversation_type": "DM",  // or "GROUP"
        "target_id": "user-b-uuid"   // or group-uuid
      }
    }
    ```
2.  **Server**: Broadcasts to target user(s):
    ```json
    {
      "type": "user_typing",
      "payload": {
        "user_id": "user-a-uuid",
        "username": "Alice",
        "conversation_type": "DM",
        "target_id": "user-b-uuid"
      }
    }
    ```

### 2. User Stops Typing
1.  **Client** (User A): After 3s of inactivity or message sent, sends:
    ```json
    {
      "type": "typing_stop",
      "payload": {
        "conversation_type": "DM",
        "target_id": "user-b-uuid"
      }
    }
    ```
2.  **Server**: Broadcasts to target user(s):
    ```json
    {
      "type": "user_stopped_typing",
      "payload": {
        "user_id": "user-a-uuid",
        "conversation_type": "DM",
        "target_id": "user-b-uuid"
      }
    }
    ```

---

## Implementation Details

### Handler Logic (Pseudocode)
```go
func handleTypingStart(client *Client, payload TypingPayload) {
    // Validate payload
    if payload.ConversationType == "DM" {
        // Send to single user
        hub.SendToUser(payload.TargetID, typingEvent)
    } else if payload.ConversationType == "GROUP" {
        // Send to all group members except sender
        members := groupRepo.GetMembers(payload.TargetID)
        for _, member := range members {
            if member.UserID != client.UserID {
                hub.SendToUser(member.UserID, typingEvent)
            }
        }
    }
}
```

---

## Client-Side Behavior (Frontend Reference)
*   **Debounce**: Send `typing_start` only once per typing session.
*   **Auto-stop**: Send `typing_stop` after 3 seconds of no input.
*   **On Send**: Immediately send `typing_stop` when message is sent.

---

## Acceptance Criteria
- [ ] **AC1** [T07.01]: When User A types in a DM with User B, User B receives `user_typing` event.
- [ ] **AC2** [T07.02]: When User A stops typing, User B receives `user_stopped_typing` event.
- [ ] **AC3**: Typing indicators work in group chats (broadcast to all members except sender).
- [ ] **AC4**: No database writes occur (stateless feature).

---

## Test Cases

### T07.01: Typing Start in DM
**Given**: User A and User B are in a DM conversation
**When**: User A sends `typing_start` event
**Then**: User B receives `user_typing` event with User A's info

### T07.02: Typing Stop in DM
**Given**: User A was typing
**When**: User A sends `typing_stop` event
**Then**: User B receives `user_stopped_typing` event

### T07.03: Typing in Group
**Given**: User A is in a group with Users B and C
**When**: User A sends `typing_start` for the group
**Then**: Users B and C receive `user_typing` event (but not User A)

---

## Security Considerations
*   **Rate Limiting**: Prevent spam by limiting typing events to 1 per second per user.
*   **Validation**: Ensure user has access to the conversation before broadcasting.
