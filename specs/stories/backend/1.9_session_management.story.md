# Story-08: Secure Refresh Token Session Management

## Background
Currently, the application uses a single short-lived Access Token. When it expires (e.g. 15 mins), the user is logged out abruptly and WebSocket connections drop. To fix this without compromising security (XSS attacks), we need a "Refresh Token" mechanism using HttpOnly cookies and database persistence.

## Objective
Implement a secure, revocable session management system using:
1.  **Access Tokens** (Short-lived, JSON storage) for API calls.
2.  **Refresh Tokens** (Long-lived, HttpOnly Cookie, DB-backed) for session renewal.

## Technical Design

### Database
**New Table**: `refresh_tokens`
- `id` (UUID, Primary Key)
- `user_id` (UUID, Foreign Key)
- `token_hash` (String, SHA256 of the raw token) - *Security Best Practice: Don't store raw tokens*
- `expires_at` (Timestamp)
- `revoked` (Boolean)
- `created_at` (Timestamp)
- `client_ip` (String, optional)
- `user_agent` (String, optional - e.g. "Chrome on Linux")

### API Endpoints
1.  **POST /auth/login** & **POST /auth/register**
    -   **Response Body**: `{"access_token": "..."}`
    -   **Response Header**: `Set-Cookie: refresh_token=<raw_token>; HttpOnly; Secure; SameSite=Strict; Path=/auth/refresh; Max-Age=604800`
    -   **Action**: Store hash of `raw_token` in `refresh_tokens` table.

2.  **POST /auth/refresh**
    -   **Request**: No body (uses Cookie).
    -   **Logic**:
        -   Extract cookie.
        -   Hash it.
        -   Find in DB where `token_hash` matches AND `revoked=false` AND `expires_at > now`.
        -   If valid: Generate new Access Token.
        -   (Optional) Rotation: Revoke old refresh token, issue new one. allow "Reuse Detection".
    -   **Response**: New Access Token (JSON) + New Cookie (optional).

3.  **POST /auth/logout**
    -   **Logic**: Find token from cookie, set `revoked=true`.
    -   **Response**: Clear Cookie.

## Tasks
- [x] Create `RefreshTokens` migration and GORM model.
- [x] Implementation of `TokenService` (Generate Access/Refresh pair).
- [x] Update `AuthService.Login` and `Register` to save tokens to DB.
- [x] Implement `Refresh` handler and route.
- [x] Implement `Logout` handler (revoke/delete).
- [x] Update Frontend `socketService` and API client to handle 401/Refresh flow.

## Acceptance Criteria
- [x] DB table `refresh_tokens` exists.
- [x] Login sets an HttpOnly cookie.
- [x] JavaScript cannot access the refresh token.
- [x] Access token expires in 15 mins (configurable).
- [x] Refresh token expires in 7 days.
- [x] Calling `/auth/refresh` with a valid cookie returns a new Access Token.
- [x] Manipulating the cookie results in 401.
- [x] Logout invalidates the token in DB.

## Frontend Implementation Plan
1.  **Dependencies**: Install `axios` for robust interceptor support.
2.  **API Client (`frontend/lib/api.ts`)**:
    -   Create `api` instance with `baseURL` and `withCredentials: true`.
    -   Add Request Interceptor: Attach `Authorization: Bearer <token>`.
    -   Add Response Interceptor:
        -   Catch `401 Unauthorized`.
        -   If `!originalRequest._retry`:
            -   Mark `_retry = true`.
            -   Call `POST /auth/refresh`.
            -   If success: Update Access Token in Redux -> Retry Original Request.
            -   If fail: Dispatch `logout` -> Redirect to Login.
3.  **Redux Auth Slice**:
    -   Ensure `isAuthenticated` persists correctly.
    -   Update `initializeAuth` to try refreshing if no token is in localStorage but a cookie might exist.
4.  **WebSocket**:
    -   Ensure `socketService.connect(token)` uses the fresh token.
    -   Handle socket disconnection on 401 by triggering the same refresh logic.
